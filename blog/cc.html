<!DOCTYPE html>
<head>
    <html>
    <head>
    <link rel="icon" type="image/png" href="../assets/logo.png">
        <meta charset="UTF-8">
        <title>call with current continuation context</title>
        <style>
</style>
<link rel="stylesheet" href="./style.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        
        <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
        
    </head>
    <body class="vscode-body">

<nav><img src="../assets/logo.png">Call/CC<a href="index.html">Back</a></nav>

        <h1 id="call-with-current-continuation-context">call with current continuation context</h1>
<h2 id="continuation-context">Continuation Context</h2>
<p>When a function calls another function, it waits for a return value to do something with.
For example, in</p>
<pre><code class="language-scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> <span class="hljs-number">1</span> (f <span class="hljs-name">x</span>))
</div></code></pre>
<p>where we assume f returns a value &quot;retVal&quot;</p>
<pre><code class="language-scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> <span class="hljs-number">1</span>  retVal)
</div></code></pre>
<p>is the continuation context if we are in (f x), it is what is going to handle the return value from x</p>
<h2 id="callcc">Call/CC</h2>
<p>call/cc takes a lambda expression with a single argument, and passes the current continuation context in as the argument.</p>
<pre><code class="language-Scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> <span class="hljs-number">1</span> (<span class="hljs-name"><span class="hljs-builtin-name">call/cc</span></span> 
	   (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (cont)
		 (<span class="hljs-name"><span class="hljs-builtin-name">display</span></span> cont)
		   (<span class="hljs-name">cont</span> <span class="hljs-number">5</span>))))
</div></code></pre>
<p>This code is fairly simple, but we can see the current continuation <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo>+</mo><mtext>  </mtext><mn>1</mn><mtext>  </mtext><mi mathvariant="normal">_</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">( + \ \ 1 \ \ \_ )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.06em;vertical-align:-0.31em;"></span><span class="mopen">(</span><span class="mord">+</span><span class="mspace"> </span><span class="mspace"> </span><span class="mord">1</span><span class="mspace"> </span><span class="mspace"> </span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mclose">)</span></span></span></span> gets passed to the lambda expression. This continuation is itself a lambda expression, if we call it with an argument it will take that argument as the argument to the continuation. This is almost like returning from a function. We can pass a value straight to the function's continuation context instead of waiting for the function to exit normally.</p>
<h2 id="application-with-multiplying-elements-of-a-list">Application with Multiplying Elements of a List</h2>
<p>First define a function multListNoCC which takes a list of numbers and multiplies them together.</p>
<pre><code class="language-Scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> multListNoCC 
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (lat)
     (<span class="hljs-name"><span class="hljs-builtin-name">cond</span></span>
        ((<span class="hljs-name"><span class="hljs-builtin-name">null?</span></span> lat) <span class="hljs-number">1</span>)
        (<span class="hljs-literal">#t</span> (<span class="hljs-name"><span class="hljs-builtin-name">*</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> lat) (<span class="hljs-name">multListNoCC</span> (<span class="hljs-name"><span class="hljs-builtin-name">cdr</span></span> lat)))))))
</div></code></pre>
<p>If any element in the list is a zero, we know the final product must be zero. Therefore we can stop multiplying the elements and just return zero as the product, this is more efficient than continuing to traverse the list. However, if we just return zero, it will just get passed back up the recursive stack. We need to &quot;pop out&quot; of all the recursive calls and return a 0 to the original caller. This is where call/cc comes in.</p>
<pre><code class="language-Scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> multList 
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (lat)
    (<span class="hljs-name"><span class="hljs-builtin-name">call/cc</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (cont)
      (<span class="hljs-name"><span class="hljs-builtin-name">letrec</span></span> ((<span class="hljs-name">helper</span> (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (x)
        (<span class="hljs-name"><span class="hljs-builtin-name">cond</span></span>
          ((<span class="hljs-name"><span class="hljs-builtin-name">null?</span></span> x) <span class="hljs-number">1</span>)
          ((<span class="hljs-name"><span class="hljs-builtin-name">eq?</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> x) <span class="hljs-number">0</span>) (<span class="hljs-name">cont</span> <span class="hljs-number">0</span>))
          (<span class="hljs-literal">#t</span> (<span class="hljs-name"><span class="hljs-builtin-name">*</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> x) (<span class="hljs-name">helper</span> (<span class="hljs-name"><span class="hljs-builtin-name">cdr</span></span> x))))))))
        (<span class="hljs-name">helper</span> lat))))))
</div></code></pre>
<p>In multList, helper is almost exactly the same as multListNoCC, just with one more condition. We wrap helper in a few lambdas that let it have access to the original CC that the function was called from.</p>
<p>We can then add another condition</p>
<pre><code class="language-Scheme"><div>((<span class="hljs-name"><span class="hljs-builtin-name">eq?</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> x) <span class="hljs-number">0</span>) (<span class="hljs-name">cont</span> <span class="hljs-number">0</span>))
</div></code></pre>
<p>which passes 0 to the original continuation context if a 0 is encountered in the list. cont is the CC before the recursion started - the original caller, so passing a value to cont effectively stops the recursion and returns a value straight back.</p>
<p>If a zero is never encountered the function will return normally by passing values all the way back up the recursive stack.</p>
<h2 id="more-examples">More examples</h2>
<pre><code class="language-scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> isNumInList
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (lat num)
    (<span class="hljs-name"><span class="hljs-builtin-name">call/cc</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (cont)
      (<span class="hljs-name"><span class="hljs-builtin-name">letrec</span></span> ((<span class="hljs-name">helper</span> (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (l n)
        (<span class="hljs-name"><span class="hljs-builtin-name">cond</span></span>
          ((<span class="hljs-name"><span class="hljs-builtin-name">null?</span></span> l) <span class="hljs-literal">#f</span>)
          ((<span class="hljs-name"><span class="hljs-builtin-name">eq?</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> l) n) (<span class="hljs-name">cont</span> <span class="hljs-literal">#t</span>))
          (<span class="hljs-literal">#t</span> (<span class="hljs-name">helper</span> (<span class="hljs-name"><span class="hljs-builtin-name">cdr</span></span> l) n ))))))
        (<span class="hljs-name">helper</span> lat num))))))
</div></code></pre>
<p>If we have found an instance of the number, there is no need to continue traversal.
If we get all the way down to the end of the list and haven't found the element, pass an #f all the way back up</p>
<pre><code class="language-scheme"><div>(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> findFirstNumInList
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (lat num)
        (<span class="hljs-name"><span class="hljs-builtin-name">call/cc</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (cont)
          (<span class="hljs-name"><span class="hljs-builtin-name">letrec</span></span> ((<span class="hljs-name">helper</span> (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (l n index)
            (<span class="hljs-name"><span class="hljs-builtin-name">cond</span></span>
              ((<span class="hljs-name"><span class="hljs-builtin-name">null?</span></span> l) <span class="hljs-literal">#f</span>)
              ((<span class="hljs-name"><span class="hljs-builtin-name">eq?</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">car</span></span> l) n) (<span class="hljs-name">cont</span> index))
              (<span class="hljs-literal">#t</span> (<span class="hljs-name">helper</span> (<span class="hljs-name"><span class="hljs-builtin-name">cdr</span></span> l) n (<span class="hljs-name"><span class="hljs-builtin-name">+</span></span> index <span class="hljs-number">1</span>)))))))
            (<span class="hljs-name">helper</span> lat num <span class="hljs-number">0</span>))))))
</div></code></pre>
<p>Much like isNumInList but returns the index of the found element</p>

    </body>
    </html>